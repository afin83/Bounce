package{        import flash.geom.Point;        import flash.media.Video;    import flash.media.Camera;        import flash.display.BitmapData;    import flash.display.Sprite;    import flash.display.Bitmap;            public class PersonDetector    {                // the subject of motion detection        private var video:Video;                // to store background state        private var oldData:BitmapData;				// to store last frame state		private var lastData:BitmapData;                // to store actual state        private var newData:BitmapData;                // stepping blocks        private var blockSize:Number;				// is the feed in reverse		private var reverse:Boolean = true;				var noActivity:Number = 0;                        public function PersonDetector ( argVideo:Video ,                                          argBlockSize:Number  )        {               video = argVideo;            blockSize = argBlockSize;                        oldData = new BitmapData( video.width , video.height , false );			lastData = new BitmapData( video.width , video.height , false );            newData = new BitmapData( video.width , video.height , false );         }                public function getDifferences ( ):Array        {            // capturing new state            newData.draw( video );						var lastframedifferences:Number = 0;                        var differences:Array = [ ];                    // looping through points with stepping            for ( var px:int = 0 ; px < newData.width ; px += blockSize )            {                                for ( var py:int = 0 ; py < newData.height ; py += blockSize )                {                                        //getting previous and actual pixel color data                    var oldPixel:uint = oldData.getPixel( px , py );                    var newPixel:uint = newData.getPixel( px , py );					var lastPixel:uint = lastData.getPixel(px,py);                                        // checking difference threshold                    if ( Math.abs( newPixel - oldPixel ) > Config.getInstance().sensitivity )                    {                        // if bigger than sensitivity, storing point						if(reverse) {                         	differences.push( new Point( video.width-px , py ) );						} else {							differences.push( new Point( px , py ) );						}                    }										if ( Math.abs( newPixel - lastPixel ) > Config.getInstance().sensitivity ) {						lastframedifferences++;					}                                    }                            }						            // save previous state			if(lastframedifferences < 20 || lastframedifferences > Config.getInstance().differenceLimit) {				noActivity++;				//trace("**"+noActivity);				//trace("NO ACTIVITY: "+noActivity,lastframedifferences);			} else {				//trace("RESET ACTIVITY, NUM DIFFS : "+lastframedifferences);				noActivity = 0;			}			if(noActivity > Config.getInstance().snapLimit) {				//oldData.copyPixels( newData , newData.rect , new Point( 0 , 0 ) );				oldData.draw(video);				//trace("SNAPPING BACKGROUND");				noActivity = 0;				Config.getInstance().snapLimit++;			}			Config.getInstance().mainClass.setInitialFrame(lastData);			Config.getInstance().mainClass.setCurrentFrame(newData);			lastData.draw( video );            return differences;           } 				public function newSnap() {			//trace("NEW SNAP");			oldData.draw(video);		}    }}