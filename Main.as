package {	import flash.geom.Point;	import flash.geom.Rectangle;	import flash.geom.ColorTransform;	import flash.media.Video;	import flash.media.Camera;	import flash.events.*;	import flash.display.Sprite;	import flash.display.Bitmap;	import flash.text.*;	import flash.display.BitmapData;	import flash.events.StatusEvent;	import flash.events.ActivityEvent;	import flash.filters.ColorMatrixFilter;	import flash.display.BlendMode;	//FILTER	import flash.filters.BitmapFilter;	import flash.filters.BitmapFilterQuality;	import flash.filters.BlurFilter;	public class Main extends Sprite {		// circle to difference point collosion radius		private static var RADIUS:Number;		// motion detection stepping		private static var BLOCKS:Number;		// bitmapdata to show detected differences for better understanding		private var helperData:BitmapData;		// colortransform to darken old difference points		private var helperTransform:ColorTransform;		private var circles:Array = new Array();		private var detector:PersonDetector;		//show the video?		private var showVideo:Boolean=Config.getInstance().videoOn;		private var showHelper:Boolean=Config.getInstance().helperOn;		private var numberOfCircles:Number=2;		private var video:Video;		private var highScore:Number=0;		//NEW STUFF		private var myTimetable:Timetable;		private var theClock:Sprite = new Sprite();		//NEW STUFF		private var theInitialFrame:BitmapData;		private var theCurrentFrame:BitmapData;		private var helper:Bitmap;		private var ripples:Sprite = new Sprite();				public var redlines:Sprite = new Sprite();		private var silhouette:Bitmap = new Bitmap();				// text box for score		private var txtFld; 		public function setInitialFrame(animage:BitmapData) {			theInitialFrame=new BitmapData(Config.getInstance().videoDimensionsX,Config.getInstance().videoDimensionsY,true);			theInitialFrame=animage;		}		public function setCurrentFrame(animage:BitmapData) {			theCurrentFrame=animage;			var theDifferenceFrame:BitmapData;			theDifferenceFrame=new BitmapData(Config.getInstance().videoDimensionsX,Config.getInstance().videoDimensionsY,true);			theDifferenceFrame.draw(theInitialFrame);			var rc:Number=1,gc:Number=1,bc:Number=1;			theDifferenceFrame.draw(theCurrentFrame,null,null,"difference");			theDifferenceFrame.applyFilter(theDifferenceFrame, theDifferenceFrame.rect, new Point(), new ColorMatrixFilter([rc, gc, bc, 0, 0,rc, gc, bc, 0, 0, rc, gc, bc, 0, 0, 0, 0, 0, 1, 0]));			silhouette.bitmapData=theDifferenceFrame;		}		public function Main( ) {			//NEW STUFF			theClock=Config.getInstance().theClock;			//NEW STUFF			//addChild(silhouette);			silhouette.scaleX=-1;			silhouette.x=Config.getInstance().videoDimensionsX;			Config.getInstance().mainClass=this;			BLOCKS=23;			RADIUS=Config.getInstance().ballRadius;			// default video size			video=new Video(Config.getInstance().videoDimensionsX,Config.getInstance().videoDimensionsY);			// bitmap to show helperData			helper = new Bitmap( );			// getting default camera			var camera:Camera=Camera.getCamera();			camera.setMode(640,480,20);			//camera.setQuality(0,100);			helperData=new BitmapData(Config.getInstance().helperDimensionsX,Config.getInstance().helperDimensionsY,true,0x000000);			helperTransform=new ColorTransform(1,1,1,.7,0,0,0,0);			helper.bitmapData=helperData;			video.attachCamera(camera );			video.scaleX=1;			//video.x = video.width;			if (showVideo) {				addChild( video );			}			if (showHelper) {				addChild( helper );			}			addChild(ripples);			addChild(redlines);			detector=new PersonDetector(video,BLOCKS);			this.addEventListener( Event.ADDED_TO_STAGE , init );			var myTimetable=new Timetable  ;			//var tmpTextField:TextField = Config.getInstance().returnTextField(false, true, Config.getInstance().timetableFormat);			var fields=Config.getInstance().getTimetableFields();			for (var i=0; i<fields.length; i++) {				addChild(fields[i]);				fields[i].y+=i*28;			}			//addChild(tmpTextField);			addChild(theClock);			stage.addEventListener(KeyboardEvent.KEY_DOWN, addBalls);						var txtFmt:TextFormat = new TextFormat();			txtFmt.font = "Helvetica";			txtFmt.size = 18;			txtFmt.bold = true;			txtFmt.leading = 4;			txtFmt.leftMargin = txtFmt.rightMargin = 6;			txtFld = new TextField();						txtFld.x=23;			txtFld.y=30;			txtFld.width=300;			txtFld.border=false;			txtFld.background=false;			txtFld.textColor=0xC1272D;			txtFld.selectable=false;			txtFld.multiline=true;			txtFld.wordWrap=true;			txtFld.defaultTextFormat = txtFmt;						txtFld.autoSize=TextFieldAutoSize.LEFT;			addChild(txtFld);		}		public function drawRipple(thex:Number,they:Number,thescore:Number) {			var tmpripple=new ripple(""+thescore+"");			tmpripple.x=thex;			tmpripple.y=they;			ripples.addChild(tmpripple);		}		public function drawRedRipple(thex:Number,they:Number,thescore:Number) {			var tmpripple=new rippleRed(""+thescore+"");			tmpripple.x=thex;			tmpripple.y=they;			ripples.addChild(tmpripple);		}				public function drawRedLine() {			var tmpredLine = new redLine();			tmpredLine.x=0;			tmpredLine.y=740;			redlines.addChild(tmpredLine);		}		public function init( event:Event ):void {			this.removeEventListener( Event.ADDED_TO_STAGE , init );			drawCircles();		}		public function drawCircles() {			for (var i:Number =0; i < numberOfCircles; i++) {				createBall();			}			stage.addEventListener( Event.ENTER_FRAME , step );		}		public function createBall() {			var circle = new MovingCircle( );			addChild( circle );			circle.init( );			circles.push(circle);		}		public function step( event:Event ):void {			//*******			var filter:BitmapFilter=getBitmapFilter();			var myFilters:Array = new Array();			myFilters.push(filter);			helper.filters=myFilters;			//*******			var differences:Array=detector.getDifferences();			for (var i:Number = 0; i<circles.length; i++) {				hitDetect(differences,circles[i]);			}			drawHelper(differences);		}		public function addBalls(e:KeyboardEvent) {			if (e.keyCode==82) {				detector.newSnap();			}			//SENSITIVITY			if (e.keyCode==190) {				Config.getInstance().sensitivity+=400000;				trace("increase sensitivity" +Config.getInstance().sensitivity);			} else if (e.keyCode == 188) {				Config.getInstance().sensitivity-=400000;				trace("decrease sensitivity= " +Config.getInstance().sensitivity);			}			//BALLSPEED			if (e.keyCode==187) {				Config.getInstance().ballSpeedx+=1;				Config.getInstance().ballSpeedy+=1;				trace("increase speed"+Config.getInstance().ballSpeedy);			} else if (e.keyCode == 189) {				trace("decrease speed");			}			//FRICTION			if (e.keyCode==50) {				Config.getInstance().friction+=.1;				trace("decrease friction"+Config.getInstance().friction);			} else if (e.keyCode == 49) {				Config.getInstance().friction-=.1;				trace("increase friction");			}			//BLOCK SIZE			if (e.keyCode==221) {				BLOCKS+=3;				trace(BLOCKS);			} else if (e.keyCode == 219) {				BLOCKS-=3;				trace(BLOCKS);			}			//NUMBER OF BALLS			if (e.keyCode==38) {				createBall();				numberOfCircles+=1;			} else if (e.keyCode == 40) {				if (circles.length>0) {					//get the last circle					var lastCircle=circles[circles.length-1];					lastCircle.cancel();					if (this.contains(lastCircle)) {						this.removeChild(lastCircle);					}					circles.splice(circles.length-1,1);					numberOfCircles-=1;				}			}		}		public function hitDetect(differences,theCircle) {			var circlePosition:Point=new Point(theCircle.x,theCircle.y);			for (var a:String in differences) {				// check distance from circle				var dr:Number=Point.distance(circlePosition,differences[a]);				// if any point is closer than RADIUS				if (dr<theCircle.width/2) {					var dx:Number=circlePosition.x-differences[a].x;					var dy:Number=circlePosition.y-differences[a].y;					theCircle.xspeed=dx*Config.getInstance().bounceSpeedx;					theCircle.yspeed=dy*Config.getInstance().bounceSpeedy;					theCircle.addtoscore(10);					Config.getInstance().mainClass.drawRipple(theCircle.x,theCircle.y,theCircle.score);					checkHighScore(theCircle.score);					break;				}			}		}		public function drawHelper(differences:Array) {			helperData.colorTransform( helperData.rect , helperTransform );			for (var b:String in differences) {				var helpRectangle:Rectangle = new Rectangle( differences[b].x , 				                                                             differences[b].y , 				                                                             BLOCKS , 				                                                             BLOCKS );				helperData.fillRect( helpRectangle , Config.getInstance().helperColour);			}		}		public function checkHighScore(newScore:Number,reset:Boolean = false) {			if (reset) {				highScore=0;			}			if (newScore>highScore) {				highScore=newScore;				txtFld.text = "CURRENT HIGH SCORE:  " + highScore;			}		}		public function resetHighScore() {			checkHighScore(0,true);		}		//*********		public function getBitmapFilter():BitmapFilter {			var blurX:Number=8;			var blurY:Number=8;			return new BlurFilter(blurX, blurY, BitmapFilterQuality.HIGH);		}	}}